\documentclass[a4paper, 14pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage{url}
\usepackage{tikz}
\usepackage{float}

\usepackage{titlesec}
\titleformat*{\section}{\LARGE\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat*{\paragraph}{\large\bfseries}
\titleformat*{\subparagraph}{\large\bfseries}

\lstset{ 
language=c++,                
basicstyle=\small\sffamily, 
numbers=left,  
numberstyle=\tiny,
stepnumber=1, 
numbersep=5pt,
showspaces=false, 
showstringspaces=false,
showtabs=false, 
frame=single, 
tabsize=2,  
captionpos=t, 
breaklines=true, 
breakatwhitespace=false, 
escapeinside={\#*}{*)} 
}

\begin{document}

\begin{titlepage}
	\centering
	{\scshape\Large Лабораторная работа №5\par}
	{\scshape\Large По курсу: "Анализ алгоритмов"\par}
	{\scshape\Large По теме: "Конвейерная обработка"\par}
	\vspace{7cm}
	\Large Студент: Кондрашова О.П.\par
	\Large Группа: ИУ7-55Б\par
	\Large Преподаватели:  Волкова Л.Л., Строганов Ю.В.\par

	\vfill
	\large \textit {Москва, 2019} \par
	\end{titlepage}
	
	\setcounter{page}{2}
	\tableofcontents
	
	\newpage
	\section*{Введение}
	
	\addcontentsline{toc}{section}{Введение}
	
		Целью данной лабораторной работы является получение навыка организации асинхронной передачи данных между потоками на примере конвейерной обработки информации.
		 
	\newpage
	\section*{Задачи работы}
	
	\addcontentsline{toc}{section}{Задачи работы}
	
	Задачи данной работы:
	
	\begin{enumerate}
\item Поставить задачу стадийной обработки;
\item спроектировать программное обеспечение, реализующее конвейерную обработку;
\item описать реализацию программного обеспечения;
\item провести тестирование программного обеспечения по времени обработки;
\item интерпретировать данные лог файла.
\end{enumerate}

	\newpage
\section{Аналитическая часть}
Конвейер — способ организации вычислений, используемый в современных процессорах и контроллерах с целью повышения их производительности (увеличения числа инструкций, выполняемых в единицу времени).

Один из самых простых и наиболее распространенных способов повышения быстродействия процессоров — конвейеризация процесса вычислений.

Конвейеризация – это техника, в результате которой задача или  команда разбивается  на некоторое число подзадач, которые  выполняются последовательно.
Каждая  подкоманда   выполняется на своем логическом  устройстве.
Все логические устройства (ступени) соединяются последовательно таким образом, что выход i-ой  ступени  связан   с   входом   (i+1)-ой   ступени,  все ступени  работают  одновременно.
Множество  ступеней называется конвейером. Выигрыш во времени достигается при выполнении  нескольких задач  за  счет параллельной   работы   ступеней,  вовлекая  на  каждом такте новую задачу или команду.

На рисунке 1 показан простой пятиуровневый конвейер в RISC-процессорах. Условные обозначения:
\begin{enumerate}
	\item IF (англ. Instruction Fetch) — получение инструкции;
	\item ID (англ. Instruction Decode) — раскодирование инструкции;
	\item EX (англ. Execute) — выполнение;
	\item MEM (англ. Memory access) — доступ к памяти;
	\item WB (англ. Register write back) — запись в регистр.
\end{enumerate}

Вертикальная ось — последовательные независимые инструкции, горизонтальная — время. Зелёная колонка описывает состояние процессора в один момент времени, в ней самая ранняя, верхняя инструкция уже находится в состоянии записи в регистр, а самая последняя, нижняя инструкция — только в процессе чтения.

 На рис. \ref{fig:pl} представлена схема конвейера.
    
    \begin{figure}[H]
        	\begin{center}
        		\includegraphics[scale=0.4]{pipeline}
        		\caption{Простой пятиуровневый конвейер в RISC-процессорах}
        		\label{fig:pl}
        	\end{center}
        \end{figure}

Идея заключается в параллельном выполнении нескольких инструкций процессора. Сложные инструкции процессора представляются в виде последовательности более простых стадий. Вместо выполнения инструкций последовательно (ожидания завершения конца одной инструкции и перехода к следующей), следующая инструкция может выполняться через несколько стадий выполнения первой инструкции. Это позволяет управляющим цепям процессора получать инструкции со скоростью самой медленной стадии обработки, однако при этом намного быстрее, чем при последовательном выполнении каждой инструкции от начала до конца.

\subsection{Оценка производительности конвейера}
\addcontentsline{toc}{section}{Оценка производительности конвейера}

Пусть задана операция, выполнение которой разбито на n последовательных этапов. При последовательном их выполнении операция выполняется за время

\begin{equation}\label{form:way}
 \tau _{e}={\sum\limits_{i=1}^n \tau _{i}}
 \end{equation}
 \begin{align*}
    \text{где} \\
    n &- \text{количество последовательных этапов;} \\
   \tau _{i} &- \text{время выполнения i-го этапа;}
\end{align*}

Быстродействие одного процессора, выполняющего только эту операцию, составит

\begin{equation}\label{form:way}
 S_{e}={\frac{1}{\tau _{e}}}={\frac{1}{\sum\limits_{i=1}^n \tau _{i}}}
 \end{equation}
 \begin{align*}
    \text{где} \\
    \tau _{e} &- \text{время выполнения одной операции;} \\
    n &- \text{количество последовательных этапов;} \\
   \tau _{i} &- \text{время выполнения i-го этапа;}
\end{align*}

Выберем время такта — величину $t _{T} = max{\sum\limits_{i=1}^n(\tau_{i})}$ и потребуем при разбиении на этапы, чтобы для любого i = 1, ... , n выполнялось условие $(\tau_{i} + \tau_{i+1}) mod n = \tau_{T}$. То есть чтобы никакие два последовательных этапа (включая конец и новое начало операции) не могли быть выполнены за время одного такта.

Максимальное быстродействие процессора при полной загрузке конвейера составляет

\begin{equation}\label{form:way}
 S_{max}={\frac{1}{\tau _{T}}}
 \end{equation}
 \begin{align*}
    \text{где} \\
    \tau _{T} &- \text{выбранное нами время такта;}
\end{align*}

Число n — количество уровней конвейера, или глубина перекрытия, так как каждый такт на конвейере параллельно выполняются n операций. Чем больше число уровней (станций), тем больший выигрыш в быстродействии может быть получен.

Известна оценка
\begin{equation}\label{form:way}
{\frac{n}{n/2} \leq {\frac{S_{max}}{S_{e}}} \leq n}
 \end{equation}
 \begin{align*}
    \text{где} \\
    S_{max} &- \text{максимальное быстродействие процессора  при полной загрузке конвейера;} \\
    S_{e} &- \text{стандартное быстродействие процессора;} \\
   n &- \text{количество этапов.}
\end{align*}

то есть выигрыш в быстродействии получается от n/2  до n раз [2].


Реальный выигрыш в быстродействии оказывается всегда меньше, чем указанный выше, поскольку:

\begin{enumerate}
\item[1)] некоторые операции, например, над целыми, могут выполняться за меньшее количество этапов, чем другие арифметические операции. Тогда отдельные станции конвейера будут простаивать;
\item[2)] при выполнении некоторых операций на определённых этапах могут требоваться результаты более поздних, ещё не выполненных этапов предыдущих операций. Приходится приостанавливать конвейер;
\item[3)] поток команд(первая ступень) порождает недостаточное количество операций для полной загрузки конвейера.
\end{enumerate}


 Генератор подает на вход конвейера (первый уровень) созданные им объекты. Далее на каждом уровне осуществляется обработка данных, занимающая определенное время. Обработанные данные передаются последовательно с одного уровня (одной ленты) конвейера на следующий (следующую ленту). Для организации работы каждой ленты будет использована очередь задач, которые должны обработаться на этой ленте. Лента будет работать, пока в ее очереди есть задачи. 
 
 Задачи попадают в очередь только в том случае, если данные уже были обработаны на предыдущем уровне или если их только сформировал генератор (для первой ленты). При этом время обработки на какой-либо ленте не должно сильно отличаться от времени обработки на остальных лентах, так как в противном случае возможны ситуации простоя одной или нескольких лент конвейера. На последнем уровне конвейера обработанные объекты попадают в пул обработанных задач.

	\subsection{Вывод}
	Был рассмотрен вычислительный конвейер 
	
	\newpage
	\section{Конструкторская часть}
	
	В данном разделе будет представлена схема работы конвейера.
	
	\subsection{Разработка конвейера}
	
	 Генератор подает на вход конвейера (первый уровень) созданные им объекты. Далее на каждом уровне осуществляется обработка данных, занимающая определенное время. Обработанные данные передаются последовательно с одного уровня (одной ленты) конвейера на следующий (следующую ленту). Для организации работы каждой ленты будет использована очередь задач, которые должны обработаться на этой ленте. Лента будет работать, пока в ее очереди есть задачи. 
 
 Задачи попадают в очередь только в том случае, если данные уже были обработаны на предыдущем уровне или если их только сформировал генератор (для первой ленты). При этом время обработки на какой-либо ленте не должно сильно отличаться от времени обработки на остальных лентах, так как в противном случае возможны ситуации простоя одной или нескольких лент конвейера. На последнем уровне конвейера обработанные объекты попадают в пул обработанных задач.
 
Реализованнй конвейер состоит из трех уровней. На каждом этапе конвейера алгоритм обработки информации заменен задержкой выполняемой программы по времени. Каждой ленте конвейера выделен отдельный поток. В главном потоке main запускаются все три рабочих потока - ленты конвейера:  first\_line, second\_line, third\_line. Для каждого потока есть своя очередь, в которой содержатся индекс выполняемой задачи и время в миллисекундах, необходимое на выполнение задачи (время задержки). Также в главном потоке генерируются входные данные, которые помещаются в очередь для первого потока. После завершения работы всех рабочих потоков проверяется массив результирующих элементов и выводится сообщение о результате работы конвейера. В рабочих потоках извлекается очередной элемент из соответствующей очереди, вносится запись в лог файл о начале обработки очередного элемента, выполняется задержка по времени. После этого новое значение помещается в очередь для следующего потока (или в массив обработанных значений если обработка происходит уже в третьем потоке) и далее в лог файл заносится запись о завершении обработки очередного элемента на определенной ленте (в определенном потоке). После окончания работы генератора в первую очередь записывается значение $-1$, что говорит о завершении работы конвейера. Это значение передается из очереди в очередь по лентам. 
	
	\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale = 0.5]{conv}}
        		\caption{Схема работы конвейера}
        	\end{center}
        \end{figure}

	\subsection{Вывод}
	
	В данном разделе был кратко описан реализованный вычислительный конвейер.

	\newpage
	\section{Технологическая часть}
	
	В этом разделе будут изложены требования к программному обеспечению и листинги алгоритмов.
	
	\subsection{Средства реализации}
	
		Данная программа разработана на языке C++, поддерживаемом многими операционными системами. Проект выполнен в среде Xcode. \\
		
		Для работы с потоками использовалась библиотека thread:
		
\begin{enumerate}
	\item joinable - проверяет потенциальную возможность работы потока в параллельном контексте;
	\item join - ожидает завершения потока.
\end{enumerate}
		
		Для реализации очереди выбрана библиотека queue:
		
\begin{enumerate}
	\item front - предоставляет доступ к первому элементу;
	\item back - предоставляет доступ к последнему элементу;
	\item empty - проверяет отсутствие элементов в контейнере, используемом для реализации;
	\item size - возвращает количество элементов в контейнере;
	\item push -вставляет элемент в конец;
	\item pop - удаляет первый элемент.
\end{enumerate}
		
		Так как в ходе работы программы возможно обращение разных потоков к одному участку памяти, используются объекты класса mutex:
		
\begin{enumerate}
	\item lock - блокирует мьютекс, выполнение останавливается если мьютекс недоступен;
	\item unlock - разблокирует мьютекс.
\end{enumerate}
	
\newpage
\subsection{Листинги функций}

В данном разделе представлены листинги реализованных алгоритмов.

В листинге \ref{m} представлена основная функция программы.\\

\begin{lstlisting}[label=m,caption=Функция main()]
int main()
{
    auto start = chrono::high_resolution_clock::now();
    
    thread thread1 (first_line);
    thread thread2 (second_line);
    thread thread3 (third_line);
    fill_objects(4);
    
    for (int i = 0; i < input_objects.size(); i++)
    {
        mtx1.lock();
        queue1.push(input_objects[i]);
        mtx1.unlock();
        sleep(3);
    }
    
    cout << "Size: " << input_objects.size() << endl;
    
    if (thread1.joinable())
    {
        thread1.join();
    }
    
    if (thread2.joinable())
    {
        thread2.join();
    }
    
    if (thread3.joinable())
    {
        thread3.join();
    }
    
    cout << "All objects passed the conveyor" << endl;
    
    auto end = chrono::high_resolution_clock::now();
    auto dur = end - start;
    auto ms = chrono::duration_cast<std::chrono::seconds>(dur).count();
    
    cout << "Time: " << ms << " sec" << endl;
    
    sort_output();
    ofstream file;
    file.open("log.txt");
    for (int i = 0; i < output_objects.size(); i++)
    {
        file << i << " " << output_objects[i].index << output_objects[i].str;
    }
    file.close();
    return 0;
}
\end{lstlisting}

В листинге \ref{t1} представлена первая лента конвейера.\\

\begin{lstlisting}[label=t1,caption=Вторая лента]
void first_line(void)
{
    bool finish = false;
    while (!finish)
    {
        mtx1.lock();
        if(!queue1.empty())
        {
            input obj = queue1.front();
            if (obj.itemindex != -1)
            {
                time(&obj.time);
                obj.index = 1;
                obj.str = " == start: ";
                resmtx.lock();
                output_objects.push_back(obj);
                resmtx.unlock();
                queue1.pop();
                sleep(1);
                mtx2.lock();
                queue2.push(obj);
                mtx2.unlock();
                obj.str = " == end: ";
                resmtx.lock();
                output_objects.push_back(obj);
                resmtx.unlock();
            }
            else
            {
                mtx2.lock();
                queue2.push(obj);
                mtx2.unlock();
                finish = true;
            }
        }
        mtx1.unlock();
    }
}
\end{lstlisting}

	\newpage
В листинге \ref{t2} представлена вторая лента конвейера.\\

\begin{lstlisting}[label=t2,caption=Вторая лента]
void second_line(void)
{
    bool finish = false;
    while (!finish)
    {
        mtx2.lock();
        if (!queue2.empty())
        {
            input obj = queue2.front();
            if (obj.itemindex != -1)
            {
                time(&obj.time);
                obj.index = 2;
                obj.str = " == start: ";
                resmtx.lock();
                output_objects.push_back(obj);
                resmtx.unlock();
                queue2.pop();
                sleep(1);
                mtx3.lock();
                queue3.push(obj);
                mtx3.unlock();
                obj.str = " == end: ";
                resmtx.lock();
                output_objects.push_back(obj);
                resmtx.unlock();
            }
            else
            {
                mtx3.lock();
                queue3.push(obj);
                mtx3.unlock();
                finish = true;
            }
        }
        mtx2.unlock();
    }
}
\end{lstlisting}

	\newpage
В листинге \ref{t3} представлена третья лента конвейера.\\

\begin{lstlisting}[label=t3,caption=Третья лента]
void third_line(void)
{
    bool finish = false;
    while (!finish)
    {
        mtx3.lock();
        if (!queue3.empty())
        {
            input obj = queue3.front();
            if (obj.itemindex != -1)
            {
                time(&obj.time);
                obj.index = 3;
                obj.str = " == start: ";
                resmtx.lock();
                output_objects.push_back(obj);
                resmtx.unlock();
                queue3.pop();
                sleep(1);
                obj.str = " == end: ";
                resmtx.lock();
                output_objects.push_back(obj);
                resmtx.unlock();
            }
            else
            {
                finish = true;
            }
        }
        mtx3.unlock();
    }
}
\end{lstlisting}

	\subsection{Вывод}

В данном разделе были представлены листинги лент конвейера.

	\newpage
	\section{Исследовательская часть}
	В данном разделе будет рассмотрен и интерпретирован лог файл.\\

	\subsection{Анализ лог файла}
	
	Для того, чтобы отследить работу потоков, необходимо получить лог файл, отражающий время начала работы ленты над очередным заданием и время окончания этой работы. 
	
	Рассмотрим лог файл для конвейера, работающего с 5 элементами.
	
	\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale = 0.7]{log}}
        		\caption{Лог файл}
        	\end{center}
        \end{figure}
	
В первом столбце показано время записи, во втором номер ленты конвейера, в третьем начало или конец обработки и номер элемента, который обрабатывался.

Проанализировав лог файл, можно увидеть, что как только заканчивается обработка элемента на первой ленте, он тут же поступает наобработку на следующую ленту. Одновременно в это время первая лента начинает обрабатывать следующий элемент.

\subsection{Время работы}

В таблице \ref{tab:par} представлено время работы конвейера для различного числа объектов:
	
\begin{table}[H]
        \caption{Таблица результатов параметризации}
            \begin{tabular}{ | c | c | }
                \hline
                 Количество объектов  &  Время (секунды)\\
                 \hline  
1 &  3 \\
3 &  9 \\
5 & 15\\
7 & 17 \\
                \hline
            \end{tabular}
        \label{tab:par}
    \end{table} 
    
    Время обработки одного входного элемента равно равно: 
    1 секунда * 3 ленты = 3 секунды.
    Для 7 входных элементов суммарное время конвейерной обработки становится меньше суммарного времени последовательной обработки: 17 секунд < 21 секунды. Аналогичная ситуация возникает и при вхождении большего числа элементов.

	\subsection{Вывод}
	
	Был получен и проанализирован лог файл.

	\newpage
	\section*{Заключение}
	
	\addcontentsline{toc}{section}{Заключение}
	
	В ходе выполнения лабораторной работы был изучен алгоритм работы конвейра с использованием методов распараллеливания процессов.
	
	\addcontentsline{toc}{section}{Список использованной литературы}

\newpage
\begin{thebibliography}{}
    \bibitem{link1}  Конвейерная обработка данных \text{https://studfiles.net/preview/1083252/page:25/}.

\end{thebibliography}

\end{document}