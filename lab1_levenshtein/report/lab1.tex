\documentclass[a4paper, 14pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage{url}
\usepackage{tikz}
\usepackage{float}

\usepackage{titlesec}
\titleformat*{\section}{\LARGE\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat*{\paragraph}{\large\bfseries}
\titleformat*{\subparagraph}{\large\bfseries}

\lstset{ 
language=c++,                
basicstyle=\small\sffamily, 
numbers=left,  
numberstyle=\tiny,
stepnumber=1, 
numbersep=5pt,
showspaces=false, 
showstringspaces=false,
showtabs=false, 
frame=single, 
tabsize=2,  
captionpos=t, 
breaklines=true, 
breakatwhitespace=false, 
escapeinside={\#*}{*)} 
}

\begin{document}

\begin{titlepage}
	\centering
	{\scshape\Large Лабораторная работа №1\par}
	{\scshape\Large По курсу: "Анализ алгоритмов"\par}
	{\scshape\Large По теме: "Расстояние Левенштейна"\par}
	\vspace{7cm}
	\Large Студент: Кондрашова О.П.\par
	\Large Группа: ИУ7-55Б\par
	\Large Преподаватели:  Волкова Л.Л., Строганов Ю.В.\par

	\vfill
	\large \textit {Москва, 2019} \par
	
\end{titlepage}

	\setcounter{page}{2}
	\tableofcontents
	
	\newpage
	\section*{Введение}
	
	\addcontentsline{toc}{section}{Введение}
	
	Цель работы: изучение метода динамического программирования на материале алгоритмов нахождения расстояния Левенштейна и расстояния Дамерау-Левенштейна.\\
	
	
	В данной работе рассматриваются три алгоритма: итеративный алгоритм нахождения расстояния Левенштейна, расстояния Дамерау-Левенштейна и рекурсивная реализация алгоритма нахождения расстояния Дамерау-Левенштейна.\\
	
	Задачи данной работы:
\begin{enumerate}
\item изучение алгоритмов нахождения расстояния Левенштейна и Дамерау-Левенштейна, нахождения расстояния между строками;
\item применение метода динамического программирования для матричной реализации указанных алгоритмов; 
\item получение практических навыков реализации указанных алгоритмов: двух алгоритмов в матричной версии и одного из алгоритмов в рекурсивной версии; 
\item сравнительный анализ линейной и рекурсивной реализаций выбранного алгоритма определения расстояния между строками по затрачиваемым ресурсам (времени и памяти); 
\item экспериментальное подтверждение различий во временнóй эффективности рекурсивной и
нерекурсивной реализаций выбранного алгоритма определения расстояния между строками при
помощи разработанного программного обеспечения на материале замеров процессорного времени
выполнения реализации на варьирующихся длинах строк; 
\item описание и обоснование полученных результатов в отчете о выполненной лабораторной
работе, выполненного как расчётно-пояснительная записка к работе. 
\end{enumerate}

	\newpage
	\section{Аналитическая часть}
	
	В данной части будут рассмотрены теоретические основы алгоритмов.
	
	\subsection{Алгоритм Левенштейна}
	Расстояние Левенштейна (также редакционное расстояние или дистанция редактирования) между двумя строками в теории информации и компьютерной лингвистике — это минимальное количество операций вставки одного символа, удаления одного символа и замены одного символа на другой, необходимых для превращения одной строки в другую.\\
	
		Область применения данных алгоритмов:
	\begin{enumerate}
\item выявление и исправление ошибок в словах при вводе, в поисковиках, в различных базах данных, в программах автоматического определения текста и т. п.
\item сравнение текстовых файлов утилитами diff и подобных ей;
\item сравнение генов, белков и хромосом в биоинформатике.
	\end{enumerate}
	
	Данный алгоритм использует понятие «цена операции». У каждой из операций вставки, замены или удаления «цена» равняется единице. У совпадения символа - нулю. Нахождение расстояния Левенштейна сводится к нахождению последовательности операций, приводящих одну строку к другой, с минимальной суммарной ценой.	\\  
	
	Классификация разрешенных операций и штрафы на выполнение операции.
	\begin{enumerate}
\item замена символа - R = 1;
\item вставка символа - I = 1;
\item удаление символа - D = 1;
\item совпадение символа - M = 0.
	\end{enumerate}
	
	Пусть $S_{1}$ и $S_{2}$ — две строки (длиной M и N соответственно) над некоторым алфавитом, тогда расстояние Левенштейна можно подсчитать по следующей рекуррентной формуле:

\begin{displaymath}
D(i,j) = \left\{ \begin{array}{ll}
 0, & \textrm{$i = 0, j = 0$}\\
 i, & \textrm{$j = 0, i > 0$}\\
 j, & \textrm{$i = 0, j > 0$}\\
min\begin{cases}
D(i,j-1)+1,\\
D(i-1, j) +1, &\textrm{$j>0, i>0$}\\
D(i-1, j-1) + (S1[i] \neq S2[j])\\
	\end{cases}
  \end{array} \right.
\end{displaymath}
	
	\newpage
	\subsection{Алгоритм Дамерау-Левенштейна}
	
	Расстояние Дамерау–Левенштейна между двумя словами — минимальное количество элементарных операций, которые необходимо совершить, чтобы получить одно слово из другого. Алгоритм является модификацией алгоритма расстояния Левенштейна. К имеющимся трем элементарным операциям добавляется операция перестановки двух соседних символов (транспозиция).\\
	
Пусть $S_{1}$ и $S_{2}$ — две строки (длиной M и N соответственно) над некоторым алфавитом, тогда расстояние Левенштейна $d(S_{1}, S_{2})$ можно подсчитать по следующей рекуррентной формуле $d(S_{1}, S_{2}) = D(M, N)$, где:
		    
		     \[ D(i, j) =  \left\{
			\begin{aligned}
				&0, && i = 0, j = 0\\
		    	&i, && i > 0, j = 0\\
		    	&j, && i = 0, j > 0\\		    	
		    	&min \left\{
				\begin{aligned}
					&D(i, j - 1) + 1,\\
		            &D(i - 1, j) + 1,\\
		            &D(i - 1, j - 1) + m(S_{1}[i], S_{2}[i]), \\
		            &D(i - 2, j - 2) + m(S_{1}[i], S_{2}[i]),\\
		        \end{aligned} \right.
		        && 
				\begin{aligned}
					&, \text{ если } i, j > 0 \\
		            & \text{ и } S_{1}[i] = S_{2}[j - 1] \\
		            & \text{ и } S_{1}[i - 1] =  S_{2}[j] \\
		        \end{aligned} \\ 
		        &min \left\{
		        \begin{aligned}
		            &D(i, j - 1) + 1,\\
		            &D(i - 1, j) + 1, \\
		            &D(i - 1, j - 1) + m(S_{1}[i], S_{2}[i]),\\
		        \end{aligned} \right.  &&, \text{иначе}
			\end{aligned} \right.
			\]	

	\subsection{Вывод}
	
	В аналитической части были рассмотрены  алгоритмы нахождения расстояния Левенштейна и его усовершенствованный алгоритм нахождения расстояния Дамерау-Левенштейна, принципиальная разница которого — наличие транспозиции. Также были рассмотрены области применения данных алгоритмов.
	
	\newpage
	\section{Конструкторская часть}
	
	В данной части будут рассмотрены схемы алгоритмов.
	
	\subsection{Схемы алгоритмов}
	
	Рассмотрим итеративные алгоритмы нахождения расстояния Левенштейна, Дамерау-Левенштейна и рекурсивный алгоритм нахождения расстояния Дамерау-Левенштейна.\\
	
	Схема алгоритма нахождения расстояния Левенштейна. \\
	\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale = 0.4]{lev}}
        		\caption{Матричный алгоритм нахождения расстояния Левенштейна}
        		\label{fig:schema_lev_matr}
        	\end{center}
        \end{figure}
	
	Схема алгоритма нахождения расстояния Дамерау-Левенштейна. \\
		\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale = 0.42]{dlev}}
        		\caption{Матричный алгоритм нахождения расстояния Дамерау-Левенштейна}
        	\end{center}
        \end{figure}
	
	\newpage
	Схема рекурсивного алгоритма нахождения расстояния Дамерау-Левенштейна. \\
	\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale = 0.4]{dlrec}}
        		\caption{Рекурсивный алгоритм нахождения расстояния Дамерау-Левенштейна}
        	\end{center}
        \end{figure}
	
	\subsection{Вывод}
	
	В данном разделе были рассмотрены схемы алгоритмов нахождения расстояния Левенштейна, Дамерау-Левенштейна, а также рекурсивный алгоритм нахождения расстояния Дамерау-Левенштейна.

	\newpage
	\section{Технологическая часть}
	
	В этом разделе будут изложены требования к программному обеспечению, средства реализации, а также представлен листинг кода.
	
	\subsection{Требования к программному обеспечению}
	
	Входные данные: str1 - первое слово, str2 - второе слово.\\
	Выходные данные: значение расстояния между двумя словами.

	\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale = 0.5]{def1}}
        		\caption{IDEF0 диаграмма нахождения расстояния Левенштейна}
        	\end{center}
        \end{figure}
	
	\subsection{Средства реализации}
	
	Данная программа разработана на языке C++, поддерживаемом многими операционными системами. Проект выполнен в среде Xcode. 
	
	Для замера процессорного времени используется функция, возвращающая количество тиков.
	
	\begin{lstlisting}[label=some-code,caption=Функция замера количества тиков]
unsigned long long tick()
{
    unsigned long long d;
    __asm__ __volatile__ ("rdtsc" : "=A" (d));
    return d;
}
\end{lstlisting}

\newpage
\subsection{Листинги функций}
\begin{lstlisting}[label=some-code,caption=Алгоритм нахождения расстояния Левенштейна]
int Levenshtein::levenshtein()
{
    matrix.clear();
    int n = str1.size();
    int m = str2.size();
    init_matrix(n, m);
    
    int cost;
    for (int i = 1; i < n + 1; i++)
    {
        for (int j = 1; j < m + 1; j++)
        {
            cost = str1[i - 1] == str2[j - 1] ? 0 : 1;
            matrix[i][j] = min(min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1), matrix[i - 1][j - 1] + cost);
        }
    }
    return matrix[n][m];
}
    
\end{lstlisting}
	\newpage
	\begin{lstlisting}[label=some-code,caption=Алгоритм нахождения расстояния Дамерау-Левенштейна]
int Levenshtein::damerau_levenshtein()
{
    matrix.clear();
    int n = str1.size();
    int m = str2.size();
    init_matrix(n, m);
    
    int cost, transp;
    for (int i = 1; i < n + 1; i++)
    {
        for (int j = 1; j < m + 1; j++)
        {
            cost = str1[i - 1] == str2[j - 1] ? 0 : 1;
            if (i > 1 && j > 1 && str1[i - 1] == str2[j - 2] && str1[i - 2] == str2[j - 1])
            {
                transp = matrix[i - 2][j - 2] + 1;
                matrix[i][j] = min(min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1), min(matrix[i - 1][j - 1] + cost, transp));
            }
            
            else
            {
                matrix[i][j] = min(min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1), matrix[i - 1][j - 1] + cost);
            }
        }
    }
    return matrix[n][m];
}
    
\end{lstlisting}
	\newpage
	\begin{lstlisting}[label=some-code,caption=Рекурсивный Алгоритм  нахождения расстояния Дамерау-Левенштейна]
int Levenshtein::damerau_levenshtein_recursive(int i, int j)
{
    if (!i)
        return j;
    if (!j)
        return i;
    
    int res, cost;
    
    cost = str1[i - 1] == str2[j - 1] ? 0 : 1;
    
    res = min(min(damerau_levenshtein_recursive(i - 1, j) + 1, damerau_levenshtein_recursive(i, j - 1) + 1), damerau_levenshtein_recursive(i - 1, j - 1) + cost);
    
    if (i > 1 and j >= 1 and str1[i - 1] == str2[j - 2] and str2[i - 1] == str1[j - 1])
    {
        res = min(res, damerau_levenshtein_recursive(i - 2, j - 2) + cost);
    }
    
    return res;
}
    
	\end{lstlisting}
	
	\subsection{Сравнительный анализ потребляемой памяти}
	
	В алгоритме нахождения расстояния Левенштейна используются:
	
\begin{table}[H]
\begin{center}
\caption{Память, используемая в алгоритме нахождения расстояния Левенштейна}
	\begin{tabular}{|c|c|}
	\hline 
	Структура данных & Занимаемая память (байты) \\ 
	\hline 
	Матрица (vector) & 24 \\ 
	\hline 
	2 строки & 48 \\ 
	\hline 
	3 вспомогательные переменные (int) & 12 \\ 
	\hline 
	2 счетчика (int) & 8 \\ 
	\hline 
	\end{tabular}
	\end{center}
	\end{table}
	
\newpage	
	В алгоритме нахождения расстояния Дамерау-Левенштейна используются:
	
\begin{table}[H]
\begin{center}
\caption{Память, используемая в алгоритме нахождения расстояния Дамерау-Левенштейна}
	\begin{tabular}{|c|c|}
	\hline 
	Структура данных & Занимаемая память (байты) \\ 
	\hline 
	Матрица (vector) & 24 \\ 
	\hline 
	2 строки & 48 \\ 
	\hline 
	4 вспомогательные переменные (int) & 16 \\ 
	\hline 
	2 счетчика (int) & 8 \\ 
	\hline 
	\end{tabular} 
	\end{center}
	\end{table}

	В рекурсивном алгоритме нахождения расстояния Дамерау-Левенштейна используются:
	
\begin{table}[H]
\begin{center}
\caption{Память, используемая в рекурсивном алгоритме нахождения расстояния Дамерау-Левенштейна}
	\begin{tabular}{|c|c|}
	\hline 
	Структура данных & Занимаемая память (байты) \\ 
	\hline 
	2 строки & 48 \\ 
	\hline 
	4 вспомогательные переменные (int) & 16 \\ 
	\hline 
	\end{tabular} 
	\end{center}
	\end{table}	

	Максимальная глубина рекурсивного вызова функции - сумма длин двух слов. 
	
	\subsection{Оценка потребляемой памяти}
	
	Оценим алгоритмы на словах длинной 4 символа:\\
	
\begin{table}[H]
\begin{center}
\caption{Память, потребляемая структурами в алгоритме нахождения расстояния Левенштейна}
	\begin{tabular}{|c|c|}
	\hline 
	Структура данных & Занимаемая память (байты) \\ 
	\hline 
	Матрица (vector) & 184 \\ 
	\hline 
	2 строки & 48 \\ 
	\hline 
	3 вспомогательные переменные (int) & 48 \\ 
	\hline 
	2 счетчика (int) & 24 \\ 
	\hline 
	Всего: & 304 \\ 
	\hline 
	\end{tabular}
	\end{center}
	\end{table}	

\begin{table}[H]
\begin{center}
\caption{Память, потребляемая структурами в алгоритме нахождения расстояния Дамерау-Левенштейн}
	\begin{tabular}{|c|c|}
	\hline 
	Структура данных & Занимаемая память (байты) \\ 
	\hline 
	Матрица (vector) & 184 \\ 
	\hline 
	2 строки & 48 \\ 
	\hline 
	4 вспомогательные переменные (int) & 64 \\ 
	\hline 
	2 счетчика (int) & 24 \\ 
	\hline 
	Всего: & 320 \\ 
	\hline 
	\end{tabular} 
	\end{center}
	\end{table}	
	
\begin{table}[H]
\begin{center}
\caption{Память, потребляемая структурами в рекурсивном алгоритме нахождения расстояния Дамерау-Левенштейна}
	\begin{tabular}{|c|c|}
	\hline 
	Структура данных & Занимаемая память (байты) \\ 
	\hline 
	2 строки & 48 \\ 
	\hline 
	4 вспомогательные переменные (int) & 16  * (4  + 4) (максимальная глубина вызовов функции) = 64\\ 
	\hline 
	Всего: & 176 \\ 
	\hline 
	\end{tabular}
	\end{center}
	\end{table}	
	
	Оценим алгоритмы на словах длинной 1000 символов:\\
	
\begin{table}[H]
\begin{center}
\caption{Память, потребляемая структурами в алгоритме нахождения расстояния Левенштейна}
	\begin{tabular}{|c|c|}
	\hline 
	Структура данных & Занимаемая память (байты) \\ 
	\hline 
	Матрица (vector) & 24024024 \\ 
	\hline 
	2 строки & 48000 \\ 
	\hline 
	3 вспомогательные переменные (int) & 12000 \\ 
	\hline 
	2 счетчика (int) & 8000 \\ 
	\hline 
	Всего: & 24092024 \\ 
	\hline 
	\end{tabular} 
	\end{center}
	\end{table}	
	
\begin{table}[H]
\begin{center}
\caption{Память, потребляемая структурами в алгоритме нахождения расстояния Дамерау-Левенштейна}
	\begin{tabular}{|c|c|}
	\hline 
	Структура данных & Занимаемая память (байты) \\ 
	\hline 
	Матрица (vector) & 24024024  \\ 
	\hline 
	2 строки & 48000 \\ 
	\hline 
	4 вспомогательные переменные (int) & 16000 \\ 
	\hline 
	2 счетчика (int) & 8000 \\ 
	\hline 
	Всего: & 24096024 \\ 
	\hline 
	\end{tabular}
	\end{center}
	\end{table}	
	
\begin{table}[H]
\begin{center}
\caption{Память, потребляемая структурами в рекурсивном алгоритме нахождения расстояния Дамерау-Левенштейна}
	\begin{tabular}{|c|c|}
	\hline 
	Структура данных & Занимаемая память (байты) \\ 
	\hline 
	2 строки & 48000 \\ 
	\hline 
	4 вспомогательные переменные (int) & 16  * (1000 +1000)(максимальная глубина вызовов функции) = 16000\\ 
	\hline 
	Всего: & 80000 \\ 
	\hline 
	\end{tabular}
	\end{center}
	\end{table}	
	
	\subsection{Вывод}
	
	В данном разделе была представлена реализация алгоритмов нахождения расстояния Левенштейна, Дамерау-Левенштейна, а также рекурсивный алгоритм нахождения расстояния Дамерау-Левенштейна. Произведен анализ по потребляемой памяти каждым из алгоритмов в входе которого был сделан вывод о том, что рекурсивный алгоритм по мере увеличения длин строк начинает выигрывать по количеству занимаемой памяти.
	
	\newpage
	\section{Исследовательская часть}
	В данной части представлены результаты  исследования быстродействия алгоритмов и затраченной памяти.\\
	
	\subsection{Тесты}
	
	Цифры в строках "Полученный результат" и "Ожидаемый результат" соответствуют расстоянию, найденному по алгоритму нахождения расстояния Левенштейна, Дамерау-Левенштейна и рекурсивной реализацией алгоритма нахождения расстояния Дамерау-Левенштейна соответственно.\\
	
\begin{table}[H]
\begin{center}
\caption{Таблица тестовых данных}
	\begin{tabular}{|c|c|c|c|c|}
	\hline 
	№ & Первое слово & Второе слово & Полученный результат & Ожидаемый результат \\ 
	\hline 
	1 & " " & " " & 0 0 0 & 0 0 0 \\ 
	\hline 
	2 & abc & " " & 3 3 3 & 3 3 3 \\ 
	\hline 
	3 & " " & abc & 3 3 3 & 3 3 3 \\ 
	\hline 
	4 & tup & dub & 2 2 2 & 2 2 2 \\ 
	\hline 
	5 & skat & kot & 2 2 2 & 2 2 2 \\ 
	\hline 
	6 & razvlechenie & uvlechenie & 3 3 3 & 3 3 3 \\ 
	\hline 
	7 & hate & hat & 1 1 1 & 1 1 1 \\ 
	\hline 
	8 & don & dun & 1 1 1 & 1 1 1 \\ 
	\hline 
	9 & mouse & mouse & 0 0 0 & 0 0 0 \\ 
	\hline 
	10 & qwer & asdf & 4 4 4 & 4 4 4 \\ 
	\hline 
	11 & qw & asdf & 4 4 4 & 4 4 4 \\ 
	\hline 
	12 & qwe & qaz & 2 2 2 & 2 2 2 \\ 
	\hline 
	13 & zaba & laba & 1 1 1 & 1 1 1 \\ 
	\hline 
	14 & ollo & lool & 3 3 2 & 3 3 2 \\ 
	\hline 
	15 & goda & pogoda & 2 2 2 & 2 2 2 \\ 
	\hline 
	\end{tabular} 
	\end{center}
	\end{table}
	
	Все тесты пройдены успешно.
	
	\subsection{Постановка эксперимента по замеру времени}
	
	Для временного сравнительного анализа рекурсивной реализации алгоритма нахождения расстояния Левенштейна, алгоритма нахождения расстояния Дамерау-Левенштейна и рекурсивного алгоритма нахождения расстояния Дамерау-Левенштейна использовалась методика многочисленных запусков программы  слов одинаковой длины (от 1 до 7 символов). Для расчета среднего времени работы алгоритмов будет использована формула $t=\frac{T_n}{N}$, где t – время выполнения, N – количество замеров. Было проведено по 20 замеров для каждой длины.\\

	\subsection{Сравнительный анализ на основе экспериментальных данных}
	
\begin{table}[H]
\begin{center}
\caption{Время работы алгоритмов (в тиках)}
	\begin{tabular} {l r r r}
	Длина  & Левенштейн & Дамерау-Левенштейн & Рек. Дамерау-Левенштейн\\
	1 & 7102 & 7069 & 99\\
	2 & 17362 & 15165 & 690\\
	3 & 24143 & 23296 & 17972\\
	4 & 35034 & 35462 & 15580\\
	5 & 33133 & 34103 & 64178\\
	6 & 46081 & 45632 & 416267\\
	7 & 57429 & 52080 & 1888863\\
	\end{tabular} 
	\end{center}
	\end{table}
	
	Сравнение итеративных алгоритмов нахождения расстояния Левенштейна и Дамерау-Левенштейна:
	
	\begin{figure}[H]
	\begin{tikzpicture}
	\begin{axis}[
	    xlabel={Длина строки},
	    ylabel={Время (тики)},
	    xmin=1, xmax=7,
	    ymin=0, ymax=60000,
	    legend pos=north west,
	    ymajorgrids=true,
	    grid style=dashed,
	]
	 
	\addplot[
	    color=red,
	    mark=square,
	    ]
	    coordinates {
	    (1,7102)(2,17362)(3,24143)(4,33130)(5,35034 )(6,46081)(7,57429)
	    };
	    
	    \addplot[
	    color=blue,
	    mark=square,
	    ]
	    coordinates {
	    (1,7069)(2,15165 )(3,23296)(4,34103)(5,35462)(6,45632)(7,52080)
	    };
	    
\addlegendentry{Лев.}
\addlegendentry{Д.-Лев.}

	\end{axis}
	\end{tikzpicture}
	\caption{Графики скорости работы итеративных алгоритмов}
	\end{figure}
	
	Сравнение итеративного и рекурсивного алгоритмов нахождения расстояния Дамерау-Левенштейна:
	
	\begin{figure}[H]
	\begin{tikzpicture}
	\begin{axis}[
	    xlabel={Длина строки},
	    ylabel={Время (тики)},
	    xmin=1, xmax=7,
	    ymin=0, ymax=1900000,
	    legend pos=north west,
	    ymajorgrids=true,
	    grid style=dashed,
	]
	    
	    \addplot[
	    color=blue,
	    mark=square,
	    ]
	    coordinates {
	    (1,7069)(2,15165 )(3,23296)(4,35462)(5,34103)(6,45632)(7,52080)
	    };
	    
	    \addplot[
	    color=green,
	    mark=square,
	    ]
	    coordinates {
	    (1,99)(2,690)(3,17972)(4,15580)(5, 64178)(6,416267)(7,1888863)
	    };

\addlegendentry{Д.-Лев.}
\addlegendentry{Рек. Д.-Лев.}

	\end{axis}
	\end{tikzpicture}
	\caption{Графики скорости работы итеративной и рекурсивной реализаций алгоритма нахождения расстояния Дамерау-Левенштейна}
	\end{figure}
	
		\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale = 0.5]{skat}}
        		\caption{Схема рекурсивного вызова в алгоритме нахождения расстояния Левенштейна (описывает часть работы алгоритма)}
        		\label{skat}
        	\end{center}
        \end{figure}
	
	На рисунке \ref{skat} видно, что рекурсивная реализация алгоритма поиска расстояния между строками использует многократный вызов функций, причем функции могут вызываться с одинаковыми аргументами. Например, 2 раза вызывается функция с аргументами "ska" и "ko". При табличном способе создается матрица, размерность которой определяется длинной слов, что позволяет оптимизировать кол-во необходимой памяти. В отличии от табличного способа, рекурсивный требует много памяти (кол-во вызовов функций при рекурсии 481, при длине слов: 4 символа). Очевидно, что рекурсивный метод проигрывает табличному по памяти и по скорости, поэтому использование такого метода становится нецелесообразным. 
	
	\subsection{Вывод}
	
	Реализации алгоритма нахождения расстояния Левенштейна и алгоритма нахождения расстояния Дамерау-Левенштейна сравнимы по времени. Худшие результаты измерений показывает рекурсивная реализация алгоритма нахождения расстояния Дамерау-Левенштейна - матричные реализации заметно выигрывают при росте длины строк. Такое замедление по времени вызвано частыми обращениями к рекурсивным запросам. Можно сделать вывод, что данная версия алгоритма не рекомендована к использованию в реальных проектах, так как она может существенно замедлить их работу.
	
	\newpage
	\section*{Заключение}
	
	\addcontentsline{toc}{section}{Заключение}
 
	В результате выполнения лабораторной работы были получены следующие основные навыки:
	\begin{enumerate}
\item изучены теоритеческие понятия в алгоритмах для нахождения расстояния Левенштейна и Дамерау-Левенштейна;
\item проведен аналитический вывод формул для заполнения матриц расстояний;
\item проведено сравнение трех реализаций заданного алгоритма, выявлены их слабые места;
\item в рамках данной работы было сделано заключение, что рекурсивный алгоритм сильно проигрывает по скорости двум другим матричным реализациям;
\item найденные скоростные отличия между матричными реализациями алгоритма Левенштейна и алгоритма Дамерау-Левенштейна крайне малы;
\item oпределение расстояния по Левенштейну имеет недостатки: a) при перестановке местами слов или частей слов получаются большие расстояния; b) расстояния между совершенно разными короткими словами будут меньше в отличии от расстояния между двумя очень похожими, но длинными словами.
	\end{enumerate}

\newpage
\addcontentsline{toc}{section}{Список  литературы}

\begin{thebibliography}{}
    \bibitem{litlink1}  Дж. Макконнелл. Анализ алгоритмов. Активный обучающий подход.-М.:Техносфера, 2009.
    \bibitem{litlink2} Нечёткий поиск в тексте и словаре // [Электронный ресурс]. Режим доступа: https://habr.com/ru/post/114997/ (дата обращения: 10.09.19).
    \bibitem{litlink3}Вычисление расстояния Левенштейна // [Электронный ресурс]. Режим доступа: https://foxford.ru/wiki/informatika/vychislenie-rasstoyaniya-levenshteyna (дата обращения: 10.09.19).
    \bibitem{litlink4}Нечеткий поиск, расстояние левенштейна алгоритм // [Электронный ресурс]. Режим доступа: https://steptosleep.ru/antananarivo-106/ (дата обращения: 10.09.19).
\end{thebibliography}
	
	\newpage
	\bibliographystyle{alpha}
	\bibliography{mybib}
	
\end{document}