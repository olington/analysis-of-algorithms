\documentclass[a4paper, 14pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage{url}
\usepackage{tikz}
\usepackage{float}

\usepackage{titlesec}
\titleformat*{\section}{\LARGE\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat*{\paragraph}{\large\bfseries}
\titleformat*{\subparagraph}{\large\bfseries}

\lstset{ 
language=c++,                
basicstyle=\small\sffamily, 
numbers=left,  
numberstyle=\tiny,
stepnumber=1, 
numbersep=5pt,
showspaces=false, 
showstringspaces=false,
showtabs=false, 
frame=single, 
tabsize=2,  
captionpos=t, 
breaklines=true, 
breakatwhitespace=false, 
escapeinside={\#*}{*)} 
}

\begin{document}

\begin{titlepage}
	\centering
	{\scshape\Large Лабораторная работа №3\par}
	{\scshape\Large По курсу: "Анализ алгоритмов"\par}
	{\scshape\Large По теме: "Алгоритмы сортировки массива"\par}
	\vspace{7cm}
	\Large Студент: Кондрашова О.П.\par
	\Large Группа: ИУ7-55Б\par
	\Large Преподаватели:  Волкова Л.Л., Строганов Ю.В.\par

	\vfill
	\large \textit {Москва, 2019} \par
	
\end{titlepage}

	\setcounter{page}{2}
	\tableofcontents
	
	\newpage
	\section*{Введение}
	
	\addcontentsline{toc}{section}{Введение}
	
Цель лабораторной работы: изучение алгоритмов сортировки массивов, сравнительный анализ времени работы данных алгоритмов, анализ трудоемкости алгоритмов.
		 
	Задачи работы:
\begin{enumerate}
	\item реализация следующих алгоритмов сортировки массивов –  сортировка вставками, сортировка пузырьком и сортировка выбором;
	\item оценка трудоемкости алгоритмов;
	\item анализ времени работы программы;
	\item сравнительный анализ работы алгоритмов для массивов размера от 100 до 1000 элементов.
\end{enumerate}

	\newpage
	\section{Аналитическая часть}
	
	В данной части будут рассмотрены теоретические основы алгоритмова, а также составлена модель для вычисления трудоемкости..
	
	\subsection{Описание алгоритмов}
	
\textbf{Сортировка вставками (Insertion Sort)}
 — это простой алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов. Сложность алгоритма: $O(n^{2})$. \cite{knut}\\

На вход алгоритма подаётся последовательность n чисел: $a_{1},a_{2},...,a_{n}$. Сортируемые числа также называют ключами. Входная последовательность на практике представляется в виде массива с n элементами. На выходе алгоритм должен вернуть перестановку исходной последовательности $a'_{1},a'_{2},...,a'_{n}$, чтобы выполнялось следующее соотношение $a'_{1} \le a'_{2} ... \le a'_{n}$\cite{korman}.\\

В начальный момент отсортированная последовательность пуста. На каждом шаге алгоритма выбирается один из элементов входных данных и помещается на нужную позицию в уже отсортированной последовательности до тех пор, пока набор входных данных не будет исчерпан. В любой момент времени в отсортированной последовательности элементы удовлетворяют требованиям к выходным данным алгоритма \cite{macconel}.\\

\textbf{Сортировка пузырьком (Bubble Sort)}
 — простой алгоритм сортировки. Для понимания и реализации этот алгоритм — простейший, но эффективен он лишь для небольших массивов. Сложность алгоритма: $O(n^{2})$. \cite{knut}\\

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются 
$N-1$ раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма).\\

Трудоемкость тела внутреннего цикла не зависит от количества элементов в массиве, поэтому оценивается как О(1). В результате выполнения внутреннего цикла, наибольший элемент смещается в конец массива неупорядоченной части, поэтому через N таких вызовов массив в любом случае окажется отсортирован. Если же массив отсортирован, то внутренний цикл будет выполнен лишь один раз. \\

Лучший случай (отсортированный массив): \\
$O(\sum\limits_{j=1}^{n-1}1)=O(n)$

Рандомный и худший (массив, отсортированный в обратном порядке) случаи: \\
$O(\sum\limits_{j=n-1}^{0}\sum\limits_{j=1}^{i}1)=O(n^2)$\\

\textbf{Сортировка выбором (Selection Sort)}
 —На массиве из $n$ элементов имеет время выполнения в худшем, среднем и лучшем случае $O(n^{2})$, предполагая что сравнения делаются за постоянное время. \cite{knut}\\

Шаги алгоритма:
\begin{enumerate}
	\item находим номер минимального значения в текущем списке;
	\item производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции);
	\item теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы;
\end{enumerate}

	
	\subsection{Модель вычислений}
	
	В рамках данной работы используется следующая модель вычислений:
	
\begin{enumerate}
  	\item Базовые операции имеют трудоемкость 1 (<, >, =, <=, =>, ==, +, -, *, /);
	\item Оператор if имеет трудоемкость, равную трудоемкости тела оператора;
	\item Оператор for имеет трудоемкость  $F_{for} = 2 + N \cdot (F_{body} + F_{cheсk})$, где $F_{body}$ – трудоемкость операций в теле цикла, а $F_{check}$ – трудоемкость проверки условия.
\end{enumerate}
	
	\subsection{Вывод}
	Были рассмотрены поверхностно алгоритмы сортировки «вставками», «пузырьком», «выбором».
	
	\newpage
	\section{Конструкторская часть}
	
	В данной части представлены схемы алгоритмов.
	
	\subsection{Схемы алгоритмов}
	
	Алгоритм сортировка вставками:
	
	\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale=0.45]{insertion}}
        		\caption{Сортировка вставками}
        	\end{center}
        \end{figure}
	
	Алгоритм сортировка пузырьком:
	
	\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale=0.63]{bubble}}
        		\caption{Сортировка пузырьком}
        	\end{center}
        \end{figure}
			
	Алгоритм сортировка выбороми:
	
	\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale=0.54]{selection}}
        		\caption{Сортировка пузырьком}
        	\end{center}
        \end{figure}
	
	\subsection{Вывод}
	
	В данной части были рассмотрены схемы алгоритмов.

	\newpage
	\section{Технологическая часть}
	
	В этом разделе будут изложены требования к программному обеспечению и листинги алгоритмов.
	
	\subsection{Требования к программному обеспечению}
	Входные данные: массив чисел, длина массива.
	Выходные данные: произведение двух матриц.

	\begin{figure}[H]
        	\begin{center}
        		{\includegraphics[scale=0.5]{3}}
        		\caption{IDEF0 диаграмма сортировки массивов}
        	\end{center}
        \end{figure}
	
	\subsection{Средства реализации}
	
		Данная программа разработана на языке C++, поддерживаемом многими операционными системами. Проект выполнен в среде Xcode. \\
	
	Для замера процессорного времени используется функция, возвращающая количество тиков.
	
	\begin{lstlisting}[label=some-code,caption=Функция замера количества тиков]
unsigned long long tick()
{
    unsigned long long d;
    __asm__ __volatile__ ("rdtsc" : "=A" (d));
    return d;
}
\end{lstlisting}

\newpage
\subsection{Листинги функций}

Листинг алгоритма сортировки вставками:
\begin{lstlisting}[label=some-code,caption=Сортировка вставками]
void insertion_sort(int* array, int array_size)
{
    int tmp, item;
    for (int i = 1; i < array_size; i++)
    {
        tmp = array[i];
        item = i - 1;
        while (item >= 0 && array[item] > tmp)
        {
            array[item + 1] = array[item];
            array[item] = tmp;
            item--;
        }
    }
}
\end{lstlisting}

Листинг алгоритма сортировки пузырьком:

	\begin{lstlisting}[label=some-code,caption=Сортировка пузырьком]
void bubble_sort(int* array, int array_size)
{
    int tmp;
    for (int i = 0; i < array_size - 1; i++)
    {
        for (int j = 0; j < array_size - i - 1; j++)
        {
            if (array[j] > array[j + 1])
            {
                tmp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = tmp;
            }
        }
    }
}
\end{lstlisting}

\newpage
Листинг алгоритма сортировки выбором:
	
	\begin{lstlisting}[label=some-code,caption=Сортировка выбором]
void selection_sort(int* array, int array_size)
{
    int min, tmp;
    for (int i = 0; i < array_size - 1; i++)
    {
      min = i;
      for (int j = i + 1; j < array_size; j++)
      {
        if (array[j] < array[min])
          min = j;
      }
      tmp = array[i];   
      array[i] = array[min];
      array[min] = tmp;
    }
}
\end{lstlisting}
	
	\subsection{Оценка трудоемкости}

Сортировка вставками:\\
$F=3+(N-1) +9W=9W+13N-10$, где W - число заходов в цикл while \\
Лучший случай  - отсортированный массив - $W= 0$\\ 
$F=13N-10$\\
Худший случай - массив, отсортированный в обратную сторону:\\
$W=\sum\limits_{i=1}^{n-1}i={{(N-1)N}\over{2}}$\\
$F=9 \cdot (N-1) \cdot N/2 + 13N -10=4.5N^2+8.5N-10$\\

	\subsection{Вывод}
	
	В данном разделе были рассмотрены листинги алгоритмов и рассчитана их трудоемкость.
	

	\newpage
	\section{Исследовательская часть}
	В данной части представлены результаты  исследования быстродействия алгоритмов.\\

	\subsection{Постановка эксперимента}
	
Для экспериментов использовались массивы, размер которых варьируется от 1000 до 10000 с шагом 1000. \\

    Количество повторов каждого эксперимента равно 20. Результат одного эксперимента рассчитывается как средний из результатов проведенных испытаний с одинаковыми входными данными. 
    
\begin{figure}[H]
\begin{tikzpicture}
\begin{axis}[
		    xlabel={Размерность массива},
		    ylabel={Время в тиках},
		    ymin = 0, ymax = 250000000,
		    legend pos=north west,
		    ymajorgrids=true,
		    grid style=dashed,
		]
		\legend{ 
	        Пузырек,
	        Выбором, 
	        Вставки,
	        }
  		\addplot[
  		    color=red,
  		    mark=square,
  		    ]
  		   coordinates {
  		    (1000,2332804)
  		    (2000,9226433)
  		    (3000,20709179)
  		    (4000,37185216)
			(5000,58317652)
			(6000,78317652)
			(7000,112353538)
			(8000,147549716)
			(9000,183282124)
			(10000,242392123)
  		    };

		\addplot[
  		    color=blue,
  		    mark=square,
  		    ]
  		    coordinates {
  		    (1000,2175366)
  		    (2000,8388355)
  		    (3000,19391760)
  		    (4000,33926124)
			(5000,51873291)
			(6000,74842766)
			(7000,100890153)
			(8000,131898738)
			(9000,167410372)
			(10000,207102281)
  		    };
  		    
  	    \addplot[
  		    color=green,
  		    mark=square,
  		    ]
  		    coordinates {
  		    (1000,17209)
  		    (2000,32808)
  		    (3000,45164)
  		    (4000,63121)
			(5000,78159)
			(6000,92945)
			(7000,98393)
			(8000,117245)
			(9000,126534)
			(10000,133098)
  		    };

	\end{axis}
	\end{tikzpicture}
	\caption{График лучших случаев сортировок}
	\end{figure}
        
      \begin{figure}[H]
	 \begin{tikzpicture}
		\begin{axis}[
		    xlabel={Размерность массива},
		    ylabel={Время в тиках},
		    ymin = 0, ymax = 330000000,
		    legend pos=north west,
		    ymajorgrids=true,
		    grid style=dashed,
		]
		\legend{ 
	        Пузырек,
	        Выбором, 
	        Вставки,
	        }
  		\addplot[
  		    color=red,
  		    mark=square,
  		    ]
  		   coordinates {
  		    (1000,3769682)
  		    (2000,15743234)
  		    (3000,41489931)
  		    (4000,71847706)
			(5000,117682400)
			(6000,149770380)
			(7000,202024988)
			(8000,264077198)
			(9000,296470986)
			(10000,326603854)
  		    };

		\addplot[
  		    color=blue,
  		    mark=square,
  		    ]
  		    coordinates {
  		    (1000,2212627)
  		    (2000,8304943)
  		    (3000,19338943)
  		    (4000,33538794)
			(5000,52535825)
			(6000,74839306)
			(7000,101190874)
			(8000,121687600)
			(9000,166493196)
			(10000,210807747)
  		    };
  		    
  	    \addplot[
  		    color=green,
  		    mark=square,
  		    ]
  		    coordinates {
  		    (1000,1867747)
  		    (2000,6705178)
  		    (3000,14394654)
  		    (4000,25580693)
			(5000,40031375)
			(6000,58358030)
			(7000,77083953)
			(8000,102215342)
			(9000,128269456)
			(10000,158476967)
  		    };

		\end{axis}
	\end{tikzpicture}
	\caption{График рандомных случаев сортировок}
	\end{figure}
	
	\begin{figure}[H]
	 \begin{tikzpicture}
		\begin{axis}[
		    xlabel={Размерность массива},
		    ylabel={Время в тиках},
		    ymin = 0, ymax =590000000,
		    legend pos=north west,
		    ymajorgrids=true,
		    grid style=dashed,
		]
		\legend{ 
	        Пузырек,
	        Выбором, 
	        Вставки,
	        }
  		\addplot[
  		    color=red,
  		    mark=square,
  		    ]
  		   coordinates {
  		    (1000,4393576)
  		    (2000,16757569)
  		    (3000,37480024)
  		    (4000,67564915)
			(5000,103074501)
			(6000,149726944)
			(7000,238420814)
			(8000,344496878)
			(9000,484304532)
			(10000,582631729)
  		    };

		\addplot[
  		    color=blue,
  		    mark=square,
  		    ]
  		    coordinates {
  		    (1000,2143739)
  		    (2000,8510610)
  		    (3000,19532155)
  		    (4000,34209409)
			(5000,53441987)
			(6000,76695119)
			(7000,103895542)
			(8000,135539496)
			(9000,167062409)
			(10000,211977374)
  		    };
  		    
  	    \addplot[
  		    color=green,
  		    mark=square,
  		    ]
  		    coordinates {
  		    (1000,4235896)
  		    (2000,14255443)
  		    (3000,30073890)
  		    (4000,52258989)
			(5000,69697451)
			(6000,75675328)
			(7000,77178197)
			(8000,102120062)
			(9000,125638167)
			(10000,157784192)
  		    };

		\end{axis}
	\end{tikzpicture}
	\caption{График худших случаев сортировок}
	\end{figure}
	
	 \newpage
	\subsection{Вывод}
	
	В результате проведенного эксперимента был получен следующий вывод: алгоритм вставок справляется лучше всех во всех трех случаях. 
	
	\newpage
	\section*{Заключение}
	
	\addcontentsline{toc}{section}{Заключение}
 
В данной лабораторной работе были выполнены следующие задачи:

\begin{enumerate}
	\item реализованы следующие алгоритмы сортировки массивов –  сортировка вставками, сортировка пузырьком и сортировка выбором;
	\item была приведена оценка трудоемкости алгоритмов;
	\item выполнен анализ времени работы программы на экспериментальных данных;
	\item выполнен сравнительный анализ работы алгоритмов для массивов размера от 100 до 1000 элементов.
\end{enumerate}

\newpage
\addcontentsline{toc}{section}{Список  литературы}

\begin{thebibliography}{11} 
   \bibitem{knut} Кнут Д. Э. 5.2.1 Сортировка путём вставок // Искусство программирования. Том 3. Сортировка и поиск = The Art of Computer Programming. Volume 3. Sorting and Searching / под ред. В. Т. Тертышного (гл. 5) и И. В. Красикова (гл. 6). — 2-е изд. — Москва: Вильямс, 2007. — Т. 3. — 832 с. — ISBN 5-8459-0082-1.
    \bibitem{korman}Кормен, Т., Лейзерсон, Ч., Ривест, Р., Штайн, К. 2.1. Сортировка вставкой // Алгоритмы: построение и анализ = Introduction to Algorithms / Под ред. И. В. Красикова. — 3-е изд. — М.: Вильямс, 2013. — С. 38-45. — ISBN 5-8459-1794-8.
     \bibitem{macconel} Макконнелл Дж. Основы современных алгоритмов = Analysis of Algorithms: An Active Learning Approach / Под ред. С. К. Ландо. — М.: Техносфера, 2004. — С. 72-76. — ISBN 5-94836-005-9.
    
    \end{thebibliography}
	\newpage
	\bibliographystyle{alpha}
	\bibliography{mybib}
	
\end{document}